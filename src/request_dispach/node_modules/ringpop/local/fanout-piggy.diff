diff --git a/lib/swim/ping-req-sender.js b/lib/swim/ping-req-sender.js
index dd37f2c..59e2bad 100644
--- a/lib/swim/ping-req-sender.js
+++ b/lib/swim/ping-req-sender.js
@@ -121,6 +121,8 @@ PingReqSender.prototype.onPingReq = function (err, res1, res2) {
         return;
     }
 
+    debugger;
+
     var res2Str = res2.toString();
     var bodyObj = safeParse(res2Str);
     if (! bodyObj || !bodyObj.changes || bodyObj.pingStatus === 'undefined') {
@@ -198,6 +200,8 @@ module.exports = function sendPingReq(opts, callback) {
                 endingStatus: pingReqMember.status
             };
 
+            debugger;
+
             // NOTE If the member is reachable, we don't explicitly
             // mark the unreachable member alive here. It happens
             // through implicit exchange of membership updates on
diff --git a/lib/swim/ping-sender.js b/lib/swim/ping-sender.js
index 8a3b51e..f0508bb 100644
--- a/lib/swim/ping-sender.js
+++ b/lib/swim/ping-sender.js
@@ -46,10 +46,14 @@ PingSender.prototype.onPing = function onPing(err, res1, res2) {
 
 // make sure that callback doesn't get run twice
 PingSender.prototype.doCallback = function doCallback(isOk, bodyObj) {
+    // XXX should we coerce to {} when isOk is false? lazy callers
+    // might only check body, and finding an object there, think that
+    // it's okay. fail early?
     bodyObj = bodyObj || {};
 
     this.ring.debugLog('ping response member=' + this.target + ' isOk=' + isOk + ' changes=' + JSON.stringify(bodyObj.changes), 'p');
 
+    // XXX should this callback follow the standard (err, res) formula?
     if (this.callback) {
         this.callback(isOk, bodyObj);
         this.callback = null;
@@ -70,32 +74,41 @@ PingSender.prototype.send = function send() {
         }
     };
     var changes = this.ring.dissemination.issueAsSender();
-    var body = JSON.stringify({
+    var bodyBase = JSON.stringify({
         checksum: this.ring.membership.checksum,
-        changes: changes,
+        changes: null,
         source: this.ring.whoami(),
         sourceIncarnationNumber: this.ring.membership.getIncarnationNumber()
     });
 
     this.ring.debugLog('ping send member=' + this.target + ' changes=' + JSON.stringify(changes), 'p');
 
-    var fan = this.getFan(changes);
+    var fanTargets = this.getFanTargets(changes);
     var self = this;
-    fan.forEach(sendSingle);
 
-    function sendSingle(target) {
+    for (var i = 0;
+         i < fanTargets.length && changes && changes.length > 0;
+         ++i, changes = this.ring.dissemination.issueAsSender()) {
+        sendSingle(fanTargets[i], changes);
+    }
+
+    function sendSingle(target, changes) {
         self.ring.channel
             .waitForIdentified({
                 host: target
-            }, onIdentified.bind(null, target));
+            }, onIdentified.bind(null, target, changes));
     }
 
-    function onIdentified(target, err) {
+    function onIdentified(target, changes, err) {
         if (err) {
             return self.onPing(err);
         }
+        // shallow copy ok cuz only mod'ing @ depth=1
+        var options = _.extend({}, optionsBase, { host: target });
+        var body = _.extend({}, bodyBase, { changes: changes });
+        
         self.ring.channel
-            .request(_.extend({}, optionsBase, { host: target }))
+            .request(options)
             .send('/protocol/ping', null, body, function (err, res, arg2, arg3) {
                 if (!err && !res.ok) {
                     err = new Error(String(arg3));
@@ -105,7 +118,7 @@ PingSender.prototype.send = function send() {
     }
 };
 
-PingSender.prototype.getFan = function getFan(changes) {
+PingSender.prototype.getFanTargets = function getFanTargets(changes) {
     var target = [this.target];
     if (changes && changes.length > 1 && this.fanoutSize > 1) {
         target = target.concat(
diff --git a/test/integration/swim-test.js b/test/integration/swim-test.js
index 06dea40..0e1446e 100644
--- a/test/integration/swim-test.js
+++ b/test/integration/swim-test.js
@@ -19,6 +19,7 @@
 // THE SOFTWARE.
 'use strict';
 
+var sendPing = require('../../lib/swim/ping-sender.js');
 var sendPingReq = require('../../lib/swim/ping-req-sender.js');
 var testRingpopCluster = require('../lib/test-ringpop-cluster.js');
 
@@ -62,6 +63,23 @@ testRingpopCluster({
     tap: function tap(cluster) {
         mkNoGossip(cluster);
     }
+}, 'ping 1 member', function t(bootRes, cluster, assert) {
+    var ringpop = cluster[0];
+    var unreachableMember = ringpop.membership.findMemberByAddress(cluster[1].hostPort);
+
+    sendPing({
+        ringpop: cluster[0],
+        target: unreachableMember,
+    }, function onPing(ok, body) {
+        assert.false(ok, 'ok is false');
+        assert.end();
+    });
+});
+
+testRingpopCluster({
+    tap: function tap(cluster) {
+        mkNoGossip(cluster);
+    }
 }, 'ping-reqs 1 member', function t(bootRes, cluster, assert) {
     var ringpop = cluster[0];
     var unreachableMember = ringpop.membership.findMemberByAddress(cluster[1].hostPort);
@@ -72,8 +90,13 @@ testRingpopCluster({
         pingReqSize: 3
     }, function onPingReq(err, res) {
         assert.ifErr(err, 'no error occurred');
+        assert.true(res, 'result returned')
+        console.log('RES:');
+        console.log(res);
+        assert.true(res.pingReqAddrs, 'result contains pingReqAddrs');
         assert.equal(res.pingReqAddrs.length, 1,
             'number of selected ping-req members is correct');
+        assert.true(res.pingReqSuccess, 'result contains pingReqSuccess');
         assert.ok(res.pingReqSuccess.address === cluster[2].hostPort,
             'successful ping-req response from either member');
         assert.end();
