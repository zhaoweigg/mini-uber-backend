diff --git a/config.js b/config.js
index f629518..410a676 100644
--- a/config.js
+++ b/config.js
@@ -73,7 +73,13 @@ Config.prototype._seed = function _seed(seed) {
             return val instanceof RegExp;
         });
     }, 'expected to be array of RegExp objects');
-    seedOrDefault('maxJoinAttempts', 50, numValidator);
+
+    //seedOrDefault('maxJoinAttempts', 50, numValidator);
+    seedOrDefault('joinAutoStart', false, boolValidator);
+    seedOrDefault('joinRequestParallelFactor', 3, positiveIntValidator);
+    seedOrDefault('joinRequestPeriodInitial', 10, positiveIntValidator);
+    seedOrDefault('joinRequestPeriodMax', 5000, positiveIntValidator);
+    seedOrDefault('joinRequestTimeout', 1000, positiveIntValidator);
 
     function seedOrDefault(name, defaultVal, validator, reason) {
         var seedVal = seed[name];
@@ -96,8 +102,31 @@ Config.prototype._seed = function _seed(seed) {
     }
 };
 
+function boolValidator(b) {
+    return typeof maybeNum === 'boolean';
+}
+
 function numValidator(maybeNum) {
     return typeof maybeNum === 'number' && !isNaN(maybeNum);
 }
 
+function intValidator(min, max) {
+    if (min === undefined) {
+        min = null;
+    }
+    if (max === undefined) {
+        max = null;
+    }
+
+    return function(n) {
+        return typeof n === 'number' &&
+            !isNaN(n) &&
+            Math.floor(n) === n &&
+            (min === null ? true : min <= n) &&
+            (max === null ? true : n <= max);
+    }
+}
+
+var positiveIntValidator = intValidator(0, Number.MAX_SAFE_INTEGER);
+
 module.exports = Config;
diff --git a/index.js b/index.js
index 09731f0..0df5ad6 100644
--- a/index.js
+++ b/index.js
@@ -55,13 +55,13 @@ var errors = require('./lib/errors.js');
 var getTChannelVersion = require('./lib/util.js').getTChannelVersion;
 var HashRing = require('./lib/ring');
 var initMembership = require('./lib/membership/index.js');
+var Joiner = require('./lib/join');
 var MembershipIterator = require('./lib/membership/iterator.js');
 var MembershipUpdateRollup = require('./lib/membership/rollup.js');
 var nulls = require('./lib/nulls');
 var rawHead = require('./lib/request-proxy/util.js').rawHead;
 var RequestProxy = require('./lib/request-proxy/index.js');
 var safeParse = require('./lib/util').safeParse;
-var sendJoin = require('./lib/swim/join-sender.js').joinCluster;
 var TracerStore = require('./lib/trace/store.js');
 
 var HOST_PORT_PATTERN = /^(\d+.\d+.\d+.\d+):\d+$/;
@@ -167,7 +167,7 @@ function RingPop(options) {
     this.statsHooks = {};
 
     this.destroyed = false;
-    this.joiner = null;
+    this.joiner = new Joiner({ ringpop: this });
 
     this.startTime = Date.now(); //used for calculating uptime
 
@@ -223,6 +223,9 @@ RingPop.prototype.setupChannel = function setupChannel() {
  *   will be sent
  */
 RingPop.prototype.bootstrap = function bootstrap(opts, callback) {
+    var self = this;
+
+    opts = opts || {};
     var bootstrapFile = opts && opts.bootstrapFile || opts || {};
 
     if (typeof bootstrapFile === 'function') {
@@ -230,25 +233,23 @@ RingPop.prototype.bootstrap = function bootstrap(opts, callback) {
         bootstrapFile = null;
     }
 
-    var self = this;
-
-    if (this.isReady) {
+    if (self.isReady) {
         var alreadyReadyMsg = 'ringpop is already ready';
-        this.logger.warn(alreadyReadyMsg, { address: this.hostPort });
+        self.logger.warn(alreadyReadyMsg, { address: self.hostPort });
         if (callback) callback(new Error(alreadyReadyMsg));
         return;
     }
 
     var bootstrapTime = Date.now();
 
-    this.seedBootstrapHosts(bootstrapFile);
+    self.seedBootstrapHosts(bootstrapFile);
 
-    if (!Array.isArray(this.bootstrapHosts) || this.bootstrapHosts.length === 0) {
+    if (!Array.isArray(self.bootstrapHosts) || self.bootstrapHosts.length === 0) {
         var noBootstrapMsg = 'ringpop cannot be bootstrapped without bootstrap hosts.' +
             ' make sure you specify a valid bootstrap hosts file to the ringpop' +
             ' constructor or have a valid hosts.json file in the current working' +
             ' directory.';
-        this.logger.warn(noBootstrapMsg);
+        self.logger.warn(noBootstrapMsg);
         if (callback) callback(new Error(noBootstrapMsg));
         return;
     }
@@ -257,10 +258,22 @@ RingPop.prototype.bootstrap = function bootstrap(opts, callback) {
     checkForHostnameIpMismatch();
 
     // Add local member to membership.
-    this.membership.makeAlive(this.whoami(), Date.now());
+    self.membership.makeAlive(self.whoami(), Date.now());
 
-    var joinTime = Date.now();
+    debugger;
+    self.joiner.addTargets(self.bootstrapHosts);
+    self.joiner.start(function(err) {
+        if (err) {
+            // XXX log, retry
+            // NO RETURN, still setup follow up services
+        }
+        self.isReady = true; // XXX can be already set?
+        if (self.gossip.isStopped /* && config.gossip... */) {
+            self.gossip.start();
+        }
+    });
 
+    /*
     sendJoin({
         ringpop: self,
         maxJoinDuration: self.maxJoinDuration,
@@ -314,11 +327,12 @@ RingPop.prototype.bootstrap = function bootstrap(opts, callback) {
 
         if (callback) callback(null, nodesJoined);
     });
+     */
 
     function checkForMissingBootstrapHost() {
         if (self.bootstrapHosts.indexOf(self.hostPort) === -1) {
             self.logger.warn('bootstrap hosts does not include the host/port of' +
-                ' the local node. this may be fine because your hosts file may' +
+                ' the local node. self may be fine because your hosts file may' +
                 ' just be slightly out of date, but it may also be an indication' +
                 ' that your node is identifying itself incorrectly.', {
                 address: self.hostPort
diff --git a/lib/join/index.js b/lib/join/index.js
new file mode 100644
index 0000000..7c5f62e
--- /dev/null
+++ b/lib/join/index.js
@@ -0,0 +1,143 @@
+// Copyright (c) 2015 Uber Technologies, Inc.
+//
+// Permission is hereby granted, free of charge, to any person obtaining a copy
+// of this software and associated documentation files (the "Software"), to deal
+// in the Software without restriction, including without limitation the rights
+// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+// copies of the Software, and to permit persons to whom the Software is
+// furnished to do so, subject to the following conditions:
+//
+// The above copyright notice and this permission notice shall be included in
+// all copies or substantial portions of the Software.
+//
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+// THE SOFTWARE.
+
+'use strict';
+
+var _ = require('underscore');
+var EventEmitter = require('events').EventEmitter;
+
+var sendJoin = require('../swim/join-sender').sendJoin;
+
+var JoinList = require('./list');
+
+function Joiner(opts, members) {
+    this.ringpop = opts.ringpop;
+    this.channel = opts.ringpop.channel;
+    this.logger = opts.logger || opts.ringpop.logger;
+    this.list = new JoinList(members);
+    // XXX
+    this.parallelismFactor = opts.ringpop.config.get('joinRequestParallelismFactor');
+    this.period = opts.ringpop.config.get('joinRequestPeriodInitial');
+    this.periodMax = opts.ringpop.config.get('joinRequestPeriodMax');
+    this.timeout = opts.ringpop.config.get('joinRequestRequestTimeout');
+
+    // nextJoin also functions as flag for whether we're active; if there's a
+    // nextJoin, then we're running.
+    this.nextJoin = null;
+    if (opts.ringpop.config.get('joinAutoStart')) {
+        this.start();
+    }
+}
+require('util').inherits(Joiner, EventEmitter);
+
+Joiner.prototype.destroy = function destroy() {
+    if (this.nextJoin) {
+        clearTimeout(this.nextJoin);
+    }
+    delete this.list;
+}
+
+Joiner.prototype.start = function start(callback) {
+    var topChannel = this.channel.topChannel;
+
+    if (this.nextJoin) {
+        callback(); // XXX error for re-call ? or idempotent? if idempotent, what is callback situation?
+        return;
+    }
+    if (topChannel.listened) {
+        this.join(callback);
+    } else {
+        topChannel.listeningEvent.on(this.join.bind(this, callback));
+    }
+}
+
+Joiner.prototype.addTargets = function addTargets(targets) {
+    this.list.add(_.without(targets, this.ringpop.whoami()))
+}
+
+Joiner.prototype.join = function join(callback) {
+    var self = this;
+    var start = Date.now();
+    var targets = this.list.sample(self.parallelismFactor);
+    var results = [];
+
+    callback = callback || function() {};
+    if (!targets || targets.length === 0) {
+        callback();
+        return
+    }
+
+    for (var i = 0; i < targets.length; ++i) {
+        sendJoin(targets[i], {
+            ringpop: self.ringpop,
+            timeout: self.timeout
+        }, onJoin);
+    }
+
+    function onJoin(err, target, joinResponse) {
+        var duration = Date.now() - start;
+
+        if (err) {
+            self.logger.error('ringpop join failed', {
+                error: err,
+                address: self.hostPort
+            });
+            callback(err);
+            return;
+        }
+
+        if (self.destroyed) {
+            callback();
+            return;
+        }
+
+        // should move up as passed in callback
+        debugger;
+        self.ringpop.membership.update(joinResponse.members, 100);
+
+        // Membership stashes all changes that have been applied since the
+        // beginning of the bootstrap process. It will then efficiently apply
+        // all changes as an 'atomic' update to membership. set() must be
+        // called before `isReady` is set to true.
+        /*
+         var setTime = Date.now();
+         self.membership.set();
+         setTime = Date.now() - setTime;
+
+         self.gossip.start();
+        self.isReady = true;
+
+        self.logger.debug('ringpop is ready', {
+            address: self.hostPort,
+            memberCount: self.membership.getMemberCount(),
+            bootstrapTime: bootstrapTime,
+            joinTime: joinTime,
+            membershipSetTime: setTime
+        });
+
+        self.emit('ready');
+         */
+
+        //callback(null, nodesJoined);
+        callback();
+    }
+}
+
+module.exports = Joiner; 
diff --git a/lib/join/list.js b/lib/join/list.js
new file mode 100644
index 0000000..a60e3b1
--- /dev/null
+++ b/lib/join/list.js
@@ -0,0 +1,109 @@
+// Copyright (c) 2015 Uber Technologies, Inc.
+//
+// Permission is hereby granted, free of charge, to any person obtaining a copy
+// of this software and associated documentation files (the "Software"), to deal
+// in the Software without restriction, including without limitation the rights
+// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+// copies of the Software, and to permit persons to whom the Software is
+// furnished to do so, subject to the following conditions:
+//
+// The above copyright notice and this permission notice shall be included in
+// all copies or substantial portions of the Software.
+//
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+// THE SOFTWARE.
+
+'use strict';
+
+var _ = require('underscore');
+var EventEmitter = require('events').EventEmitter;
+
+function JoinList(members) {
+    members = members || [];
+
+    this.members = {};
+    this.add(members);
+}
+require('util').inherits(JoinList, EventEmitter);
+
+JoinList.prototype.add = function add() {
+    var targets = flattenAndUnique(arguments);
+    var added = [];
+    for (var i = 0; i < targets.length; ++i) {
+        var target = targets[i];
+        if (!this.members[target]) {
+            var state = {};
+            this.members[target] = state;
+            added.push(target);
+        }
+    }
+    if (added.length) {
+        process.nextTick(this.emit.bind(this, 'add', added));
+    }
+};
+
+JoinList.prototype.remove = function remove() {
+    var targets = flattenAndUnique(arguments);
+    var removed = [];
+    for (var i = 0; i < targets.length; ++i) {
+        var target = targets[i];
+        var state = this.members[target];
+        if (state) {
+            delete this.members[target];
+            removed.push(target);
+        }
+    }
+    if (removed.length) {
+        process.nextTick(this.emit.bind(this, 'remove', removed));
+    }
+};
+
+JoinList.prototype.update = function update() {
+    var current = Object.keys(this.members);
+    var targets = flattenAndUnique(arguments);
+    var targetSet = {};
+
+    var adds = [];
+    for (var i = 0; i < targets.length; ++i) {
+        var target = targets[i];
+        targetSet[target] = true;
+        if (!this.members[target]) {
+            adds.push(target);
+        }
+    }
+
+    var removes = [];
+    for (i = 0; i < current.length; ++i) {
+        if (!targetSet[current[i]]) {
+            removes.push(current[i]);
+        }
+    }
+
+    this.remove(removes);
+    this.add(adds);
+};
+
+JoinList.prototype.sample = function sample(n) {
+    return _.sample(Object.keys(this.members), n || 1);
+};
+
+JoinList.prototype.shuffle = function shuffle() {
+    return _.shuffle(Object.keys(this.members));
+};
+
+// overkill?
+JoinList.prototype.get = function get(target) {
+    return this.members[target];
+};
+
+function flattenAndUnique(args) {
+    args = Array.prototype.slice.call(args);
+    return _.chain(args).flatten().unique().value();
+}
+
+module.exports = JoinList; 
diff --git a/lib/membership/index.js b/lib/membership/index.js
index de3be97..da4fa08 100644
--- a/lib/membership/index.js
+++ b/lib/membership/index.js
@@ -239,28 +239,35 @@ Membership.prototype.set = function set() {
     }
 };
 
-Membership.prototype.update = function update(changes, isLocal) {
+// batchDelay is brittle and assumes that if there's already a batch, it just
+// tacks on. No obvious need to apply real 'max' semantics here. First come,
+// first served.
+Membership.prototype.update = function update(changes, isLocal, batchDelay) {
+    changes = changes || [];
     changes = Array.isArray(changes) ? changes : [changes];
+    this.stashedUpdates = this.stashedUpdates.concat(changes);
 
-    this.ringpop.stat('gauge', 'changes.apply', changes.length);
-
-    if (changes.length === 0) {
-        return [];
-    }
+    // XXX whoah batman!!! changing a stat?!?
+    this.ringpop.stat('gauge', 'changes.add', changes.length);
 
-    // Buffer updates until ready.
-    if (!isLocal && !this.ringpop.isReady) {
-        if (Array.isArray(this.stashedUpdates)) {
-            this.stashedUpdates.push(changes);
+    if (batchDelay) {
+        if (!this._applyTimer) {
+            this._applyTimer = setTimeout(this._apply.bind(this), batchDelay);
         }
-
-        return [];
+        return null;
     }
 
+    return this._apply();
+};
+
+// Apply any outstanding batched updates.
+Membership.prototype._apply = function _apply() {
     // Changes will be evaluated against membership update rules.
     // Not all changes will be applied.
     var self = this;
     var updates = [];
+    var changes = this.stashedUpdates;
+    this.ringpop.stat('gauge', 'changes.apply', changes.length);
 
     for (var i = 0 ; i < changes.length; i++) {
         var change = changes[i];
@@ -296,6 +303,12 @@ Membership.prototype.update = function update(changes, isLocal) {
         this.emit('updated', updates);
     }
 
+    if (this._applyTimer) {
+        clearTimeout(this._applyTimer);
+    }
+    this._applyTimer = null;
+    this.stashedUpdates = [];
+
     return updates;
 
     function onMemberUpdated(update) {
@@ -309,7 +322,7 @@ Membership.prototype.update = function update(changes, isLocal) {
 
         updates.push(update);
     }
-};
+}
 
 Membership.prototype.shuffle = function shuffle() {
     this.members = _.shuffle(this.members);
diff --git a/lib/swim/join-sender.js b/lib/swim/join-sender.js
index d938994..ddbc67b 100644
--- a/lib/swim/join-sender.js
+++ b/lib/swim/join-sender.js
@@ -107,18 +107,6 @@ function JoinCluster(opts) {
     this.parallelismFactor = numOrDefault(opts.parallelismFactor,
         PARALLELISM_FACTOR);
 
-    // We eventually want to give up if the join process cannot
-    // succeed. `maxJoinDuration` is used to restrict that process
-    // to a certain time limit.
-    this.maxJoinDuration = numOrDefault(opts.maxJoinDuration,
-        MAX_JOIN_DURATION);
-
-    // We do not want to retry joining as hard as we can. We
-    // want to have some fixed backoff applied before we try
-    // to join again
-    this.joinRetryDelay = numOrDefault(opts.joinRetryDelay,
-        JOIN_RETRY_DELAY);
-
     // Potential nodes are nodes in the ringpop bootstrap
     // list that can be joined. Upon instantiation, this step
     // simply filters out a node from attempting to join itself.
@@ -126,12 +114,6 @@ function JoinCluster(opts) {
     this.preferredNodes = null;
     this.nonPreferredNodes = null;
 
-    // We either join the number of nodes defined by `joinSize`
-    // or limit it to the number of `potentialNodes`. After all,
-    // we can't join more than there are to join in the first place.
-    var joinSize = numOrDefault(opts.joinSize, JOIN_SIZE);
-    this.joinSize = Math.min(joinSize, this.potentialNodes.length);
-
     // A round is defined as a complete cycle through all
     // potential join targets. Once a round is completed,
     // we start all over again. A full-cycle should be pretty
@@ -492,7 +474,62 @@ function joinCluster(opts, callback) {
     return joiner;
 }
 
+function sendJoin(target, opts, callback) {
+    var joinOpts = {
+        host: target,
+        timeout: opts.joinTimeout,
+        serviceName: 'ringpop',
+        hasNoParent: true,
+        retryLimit: 0,
+        trace: false,
+        headers: {
+            'as': 'raw',
+            'cn': 'ringpop'
+        }
+    };
+    var joinBody = JSON.stringify({
+        app: opts.ringpop.app,
+        source: opts.ringpop.whoami(),
+        incarnationNumber: opts.ringpop.membership.localMember.incarnationNumber
+    });
+
+    console.log('Idenfity');
+    opts.ringpop.channel
+        .waitForIdentified({host: joinOpts.host}, onIdentified);
+
+    function onIdentified(err) {
+        if (err) {
+            callback(err);
+            return;
+        }
+        console.log('Identified');
+        opts.ringpop.channel
+            .request(joinOpts)
+            .send('/protocol/join', null, joinBody, onSent);
+    }
+
+    function onSent(err, res, head, body) {
+        if (!err && !res.ok) {
+            err = new Error(String(body));
+        }
+        if (err) {
+            return callback(err, target);
+        }
+
+        console.log('Sent');
+        var bodyObj = safeParse(body.toString());
+        if (bodyObj) {
+            bodyObj = {
+                checksum: bodyObj.membershipChecksum,
+                members: bodyObj.membership
+            };
+        }
+        callback(null, target, bodyObj);
+    }
+};
+
 module.exports = {
     createJoiner: createJoiner,
-    joinCluster: joinCluster
+    joinCluster: joinCluster,
+    sendJoin: sendJoin
 };
diff --git a/main.js b/main.js
index 1e0167b..6ec8aca 100755
--- a/main.js
+++ b/main.js
@@ -40,6 +40,7 @@ function main(args) {
         logger: createLogger('tchannel'),
     });
 
+
     var ringpop = new RingPop({
         app: 'ringpop',
         hostPort: listen,
@@ -51,13 +52,13 @@ function main(args) {
 
     ringpop.setupChannel();
 
-    ringpop.channel.on('listening', function onListening() {
-        ringpop.channel.removeListener('listening', onListening);
+    tchannel.on('listening', function onListening() {
+        tchannel.removeListener('listening', onListening);
         ringpop.bootstrap(program.hosts);
     });
 
     var listenParts = listen.split(':');
-    ringpop.channel.listen(Number(listenParts[1]), listenParts[0]);
+    tchannel.listen(Number(listenParts[1]), listenParts[0]);
 }
 
 function createLogger(name) {
diff --git a/server/protocol/join.js b/server/protocol/join.js
index beb6022..2cc9440 100644
--- a/server/protocol/join.js
+++ b/server/protocol/join.js
@@ -100,6 +100,7 @@ function validateJoinerApp(ringpop, app, callback) {
 
 module.exports = function createJoinHandler(ringpop) {
     return function handleJoin(arg1, arg2, hostInfo, callback) {
+        debugger;
         var body = safeParse(arg2.toString());
         if (body === null) {
             return callback(new Error('need JSON req body with source and incarnationNumber'));
