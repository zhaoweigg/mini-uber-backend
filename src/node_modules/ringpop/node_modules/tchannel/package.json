{
  "name": "tchannel",
  "description": "network multiplexing and framing protocol for RPC or parser drag racing",
  "author": {
    "name": "mranney@uber.com"
  },
  "version": "3.6.24",
  "scripts": {
    "lint": "eslint $(git ls-files | grep '.js$')",
    "travis": "npm run test",
    "test": "npm run check-licence && npm run lint -s && npm run cover -s && npm run check-benchmark -s",
    "benchmark": "echo '!!! DEPRECATED: Better to just run `node benchmarks` directly' >&2; node benchmarks",
    "hyperbahn-link-test": "./test/link_hyperbahn.sh",
    "tcurl-link-test": "./test/link_tcurl.sh",
    "check-benchmark": "node benchmarks -- -r 10000 -p 750",
    "take-benchmark": "make -C benchmarks take",
    "take-relay-benchmark": "make -C benchmarks take_relay",
    "take-trace-benchmark": "amke -C benchmarks take_trace",
    "cover": "npm run check-files && npm run test-cover && istanbul check-coverage",
    "check-files": "bash scripts/verify_included.sh",
    "test-cover": "istanbul cover --report html --print none test/index.js -- --color | faucet && istanbul report text",
    "check-cover": "istanbul check-coverage",
    "view-cover": "opn coverage/index.html",
    "check-licence": "uber-licence --dry",
    "add-licence": "uber-licence"
  },
  "main": "channel",
  "repository": {
    "type": "git",
    "url": "git@github.com:uber/tchannel-node"
  },
  "dependencies": {
    "bufrw": "^1.2.1",
    "crc": "^3.2.1",
    "error": "^7.0.1",
    "farmhash": "1.1.0",
    "json-stringify-safe": "^5.0.0",
    "metrics": "^0.1.8",
    "minimist": "^1.1.0",
    "process": "0.11.1",
    "raw-body": "^2.1.2",
    "ready-signal": "^1.1.1",
    "run-parallel": "^1.1.0",
    "run-series": "^1.1.2",
    "safe-json-parse": "^4.0.0",
    "sse4_crc32": "4.1.1",
    "tape-cluster": "2.1.0",
    "thriftrw": "^3.4.3",
    "xorshift": "^0.2.0",
    "xtend": "^4.0.0"
  },
  "devDependencies": {
    "ansi-color": "^0.2.1",
    "async": "^0.9.0",
    "chalk": "^1.0.0",
    "child_pty": "3.0.1",
    "collect-parallel": "^1.0.1",
    "debug-logtron": "5.1.1",
    "duplexer": "^0.1.1",
    "eslint": "0.24.0",
    "eslint-config-perf-standard": "1.0.0",
    "faucet": "0.0.1",
    "format-stack": "4.1.1",
    "hexer": "^1.4.5",
    "istanbul": "^0.3.13",
    "lb_pool": "^1.4.0",
    "ldjson-stream": "^1.2.1",
    "loadtest": "1.2.14",
    "my-local-ip": "1.0.0",
    "once": "^1.3.1",
    "opn": "^1.0.1",
    "replr": "^1.0.4",
    "split2": "^0.2.1",
    "tape": "^4.0.0",
    "through2": "^0.6.3",
    "time-mock": "^0.1.2",
    "uber-licence": "^1.1.0",
    "uber-statsd-client": "1.3.2"
  },
  "pre-commit": [],
  "pre-commit.silent": true,
  "readme": "# TChannel\n\nnetwork multiplexing and framing protocol for RPC\n\n## Stability: stable\n\n[![stable](http://badges.github.io/stability-badges/dist/stable.svg)](http://github.com/badges/stability-badges)\n\n## Example\n\n```js\nvar TChannel = require('tchannel');\n\nvar server = new TChannel();\nvar client = new TChannel();\n\nvar serverChan = server.makeSubChannel({\n    serviceName: 'server'\n});\n\n// normal response\nserverChan.register('func1', function onReq(req, res, arg2, arg3) {\n    console.log('func1 responding', { arg2: arg2.toString(), arg3: arg3.toString() });\n    res.headers.as = 'raw';\n    res.sendOk('result', 'indeed it did');\n});\n\n// err response\nserverChan.register('func2', function onReq2(req, res) {\n    res.headers.as = 'raw';\n    res.sendNotOk(null, 'it failed');\n});\n\nserver.listen(4040, '127.0.0.1', function onListen() {\n    var clientChan = client.makeSubChannel({\n        serviceName: 'server',\n        peers: [server.hostPort],\n        requestDefaults: {\n            hasNoParent: true,\n            headers: { 'as': 'raw', 'cn': 'example-client' }\n        }\n    });\n\n    clientChan.request({\n        serviceName: 'server',\n        timeout: 1000\n    }).send('func1', 'arg 1', 'arg 2', function onResp(err, res, arg2, arg3) {\n        console.log('normal res:', { arg2: arg2.toString(), arg3: arg3.toString() });\n    });\n\n    clientChan.request({\n        serviceName: 'server'\n    }).send('func2', 'arg 1', 'arg 2', function onResp(err, res, arg2, arg3) {\n        console.log('err res: ', { ok: res.ok, message: String(arg3) });\n    });\n});\n```\n\nThis example registers two functions on the \"server\". \"func 1\" always works and \"func 2\" always\nreturns an error. The client sends a request for each function, then prints the result.\n\nNote that every instance is bidirectional. New connections are initiated on demand.\n\n## Overview\n\nTChannel is a network protocol with the following goals:\n\n * request / response model\n * multiple requests multiplexed across the same TCP socket\n * out of order responses\n * streaming request and responses\n * all frames checksummed\n * transport arbitrary payloads\n * easy to implement in multiple languages\n * near-redis performance\n\nThis protocol is intended to run on datacenter networks for inter-process communication.\n\n## Protocol\n\nTChannel frames have a fixed length header and 3 variable length fields. The underlying protocol\ndoes not assign meaning to these fields, but the included client/server implementation uses\nthe first field to represent a unique endpoint or function name in an RPC model.\nThe next two fields can be used for arbitrary data. Some suggested way to use the 3 fields are:\n\n* URI path, HTTP method and headers as JSON, body\n* function name, headers, thrift / protobuf\n\nNote however that the only encoding supported by TChannel is UTF-8.  If you want JSON, you'll need\nto stringify and parse outside of TChannel.\n\nThis design supports efficient routing and forwarding of data where the routing information needs\nto parse only the first or second field, but the 3rd field is forwarded without parsing.\n\nThere is no notion of client and server in this system. Every TChannel instance is capable of\nmaking or receiving requests, and thus requires a unique port on which to listen. This requirement may\nchange in the future.\n\n - See [protocol.md](../docs/protocol.md) for more details\n\n## Performance\n\nOn a Macbook Pro, we see around 50,000 ops/sec from a single node process talking to one other node process.\n\n## Documentation\n\nSee the [docs](./docs/) folder.\n\n## Further examples\n\nSee the [examples](./examples/) folder\n\n## Installation\n\n`npm install tchannel`\n\n## Tests\n\n`npm test`\n\n## Contributors\n\n - mranney\n - jwolski\n - Raynos\n - jcorbin\n - kriskowal\n - shannili\n - rf\n\n## MIT Licenced\n",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/uber/tchannel-node/issues"
  },
  "_id": "tchannel@3.6.24",
  "dist": {
    "shasum": "41a43e972cc51dba3cecbbf4e426e7b54ceb5d3c"
  },
  "_from": "tchannel@^3.6.13",
  "_resolved": "https://registry.npmjs.org/tchannel/-/tchannel-3.6.24.tgz"
}
