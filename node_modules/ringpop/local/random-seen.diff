diff --git a/index.js b/index.js
index 0f20432..87ae097 100644
--- a/index.js
+++ b/index.js
@@ -189,40 +189,41 @@ RingPop.prototype.destroy = function destroy() {
 
 RingPop.prototype.setupChannel = function setupChannel() {
     createServer(this, this.channel);
 };
 
 RingPop.prototype.adminLeave = function adminLeave(callback) {
     handleAdminLeave({
         ringpop: this
     }, callback);
 };
 
 /*
  * opts are:
  *   - bootstrapFile: File or array used to seed join process
  *   - joinParallelismFactor: Number of nodes in which join request
  *   will be sent
  */
 RingPop.prototype.bootstrap = function bootstrap(opts, callback) {
     var bootstrapFile = opts && opts.bootstrapFile || opts || {};
 
+    // XXX can this occur, since opts && opts.bootstrapFile would be null for a func?
     if (typeof bootstrapFile === 'function') {
         callback = bootstrapFile;
         bootstrapFile = null;
     }
 
     var self = this;
 
     if (this.isReady) {
         var alreadyReadyMsg = 'ringpop is already ready';
         this.logger.warn(alreadyReadyMsg, { address: this.hostPort });
         if (callback) callback(new Error(alreadyReadyMsg));
         return;
     }
 
     var bootstrapTime = Date.now();
 
     this.seedBootstrapHosts(bootstrapFile);
 
     if (!Array.isArray(this.bootstrapHosts) || this.bootstrapHosts.length === 0) {
         var noBootstrapMsg = 'ringpop cannot be bootstrapped without bootstrap hosts.' +
diff --git a/lib/membership-update-listener.js b/lib/membership-update-listener.js
index 41ceb00..51d6445 100644
--- a/lib/membership-update-listener.js
+++ b/lib/membership-update-listener.js
@@ -26,40 +26,41 @@ module.exports = function createListener(ringpop) {
         var serversToAdd = [];
         var serversToRemove = [];
 
         for (var i = 0; i < updates.length; i++) {
             var update = updates[i];
 
             ringpop.stat('increment', 'membership-update.' + (update.status || 'unknown'));
 
             if (update.status === Member.Status.alive) {
                 serversToAdd.push(update.address);
                 ringpop.suspicion.stop(update);
             } else if (update.status === Member.Status.suspect) {
                 ringpop.suspicion.start(update);
             } else if (update.status === Member.Status.faulty) {
                 serversToRemove.push(update.address);
                 ringpop.suspicion.stop(update);
             } else if (update.status === Member.Status.leave) {
                 serversToRemove.push(update.address);
                 ringpop.suspicion.stop(update);
             }
+            // XXX incongruence w/ || 'unknown' above -- log? or early fail/bail?
 
             ringpop.dissemination.recordChange(update);
 
             ringpop.logger.debug('member updated', {
                 local: ringpop.whoami(),
                 address: update.address,
                 incarnationNumber: update.incarnationNumber,
                 status: update.status
             });
         }
 
         // Must add/remove servers from ring in batch. There are
         // efficiency gains when only having to compute the ring
         // checksum once.
         if (serversToAdd.length > 0 || serversToRemove.length > 0) {
             var ringChanged = ringpop.ring.addRemoveServers(serversToAdd, serversToRemove);
 
             if (ringChanged) {
                 ringpop.emit('ringChanged');
             }
diff --git a/lib/membership.js b/lib/membership.js
index 64c8f9e..bba3242 100644
--- a/lib/membership.js
+++ b/lib/membership.js
@@ -200,40 +200,41 @@ Membership.prototype.set = function set() {
     this.emit('set', updates);
 
     function reduceUpdates(total, updates) {
         total += updates.length;
         return total;
     }
 };
 
 Membership.prototype.update = function update(changes, isLocal) {
     changes = Array.isArray(changes) ? changes : [changes];
 
     this.ringpop.stat('gauge', 'changes.apply', changes.length);
 
     if (changes.length === 0) {
         return [];
     }
 
     // Buffer updates until ready.
     if (!isLocal && !this.ringpop.isReady) {
         if (Array.isArray(this.stashedUpdates)) {
+            // XXX extend, since changes is an Array? I'm probably misunderstanding here.
             this.stashedUpdates.push(changes);
         }
 
         return [];
     }
 
     // Changes will be evaluated against membership update rules.
     // Not all changes will be applied.
     var self = this;
     var updates = [];
 
     for (var i = 0 ; i < changes.length; i++) {
         var change = changes[i];
 
         var member = this.findMemberByAddress(change.address);
 
         // If first time seeing member, take change wholesale.
         if (!member) {
             applyUpdate(change);
             updates.push(change);
