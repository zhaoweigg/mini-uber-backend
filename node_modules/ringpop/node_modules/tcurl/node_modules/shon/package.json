{
  "name": "shon",
  "description": "A JavaScript command-line argument parser",
  "author": {
    "name": "Kris Kowal",
    "email": "kris@cixar.com"
  },
  "version": "3.0.5",
  "directories": {
    "test": "test"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/kriskowal/shon.git"
  },
  "keywords": [
    "argument",
    "parser",
    "command"
  ],
  "license": "MIT",
  "bugs": {
    "url": "https://github.com/kriskowal/shon/issues"
  },
  "homepage": "https://github.com/kriskowal/shon#readme",
  "main": "./command.js",
  "bin": {
    "shon": "bin/shon.js",
    "usage2json": "bin/usage2json.js"
  },
  "devDependencies": {
    "faucet": "0.0.1",
    "istanbul": "^0.3.21",
    "opn-cli": "^1.0.0",
    "pegjs": "^0.9.0",
    "tape": "^4.2.0"
  },
  "dependencies": {
    "camelcase": "^1.2.1",
    "rezult": "^1.1.0"
  },
  "scripts": {
    "test": "npm run build-parser -s && node test",
    "cover": "istanbul cover --report html --print node test/index.js -- --color | faucet && istanbul report text",
    "view-cover": "opn coverage/index.html",
    "build-parser": "pegjs --allowed-start-rules line,document usage.pegjs usage-parser.js"
  },
  "readme": "\n# shon\n\nShon is a JavaScript command-line argument parser.\nFully describe your command's interface using familiar usage notation.\nSince the declarations are complete, Shon can provide informative errors for\nall missing or invalid configuration values.\nShon supports both optional and required flags and arguments, as well as\nsubcommands.\n\nShon also supports a recursive descent parser for Shell Object Notation (SHON),\nso complex objects can be expressed as command line arguments.\n\n## Installation\n\n```\n$ npm install --save shon\n```\n\n## Common Boolean Flags\n\nA boolean flag is an option that switches a config value from false to true.\n\n```js\nvar Command = require('shon/command');\nvar command = new Command('dwim', {\n    bool: '[-b|--bool] A boolean flag'\n});\n\nvar config = command.exec();\nconsole.log(config.bool);\n```\n\n```\n$ dwim\nfalse\n\n$ dwim -b\ntrue\n```\n\nA boolean flag should only be provided once.\n\n```\n$ dwim -bb\nRedundant: bool\ndwim -b -b\n        ^\nusage: dwim\n  [-b|--bool] A boolean flag\n```\n\n## Troll\n\nThe Bridge Troll accepts three required arguments.\nThey can be taken by position, or in any order with flags.\nThe last argument is a number, so the `:quantity` type annotation ensures that\nthe value on the command line is converted to a number and is a valid, positive\nnumber. The `:number` annotation merely validates that the value is a number.\n\n```js\nvar command = new Command('troll\\n' +\n    'Answer me these questions three, ere the other side ye see.', {\n    name: '[-n|--name] <name> What is your name?',\n    color: '[-c|--color] <color> What is your favorite colour?',\n    airspeed: '[-a|--airspeed] <airspeed> :quantity What is the average ' +\n        'airspeed velocity of an unladen swallow?'\n});\n\nvar config = command.exec();\n\nconsole.log('Name:', config.name);\nconsole.log('Color:', config.color);\nconsole.log('Airpseed:', config.airspeed);\n```\n\nThe square brackets around the flags denote that the flag is optional but the\nargument is not.\n\n## Cut\n\nThe cut command accepts two optional arguments with custom default values, a\ncustom converter, and a custom validator.\nThe square brackets around the flag and argument denote that the argument is\noptional and must be specified with the flag.\n\n```js\n'use strict';\n\nvar Command = require('shon/command');\n\nvar command = new Command('cut', {\n    delim: '[-d <delim>] The delimiter to split on, space by default',\n    fields: '[-f <fields>] Comma separated field numbers',\n    input: '[<file>{1..}] :input The file or files to read, or standard input'\n});\n\ncommand.delim.default = ' ';\n\ncommand.fields.converter = function convert(fields) {\n    var parts = fields.split(',');\n    return parts.map(Number);\n};\n\ncommand.fields.validator = function validate(fields) {\n    return fields.every(isNumber);\n};\n\nfunction isNumber(number) {\n    return number === number; // Just excludes NaN\n}\n\nvar config = command.exec();\n\n// using config.delim and config.fields...\n// see demos/cut.js\nconfig.input.forEach(onInput);\n```\n\n## Sum\n\nThe sum command accepts any number of arguments and computes their sum.\n\n```js\nvar Command = require('shon/command');\nvar command = new Command('sum computes the sum of multiple numbers', {\n    numbers: '<number>... :number'\n});\nvar config = command.exec();\nconsole.log(config.numbers.reduce(function add(a, b) {\n    return a + b;\n}));\n```\n\n```\n$ sum\n0\n\n$ sum 1 2 3\n6\n\n$ sum a\nInvalid: number\nsum a\n    ^\n```\n\n## Soup\n\nThe soup command illustrates a single configuration variable that can be true\nor false depending on which of several flags are given.\nEach flag has its own corresponding value, indicated by its `=` expression,\nand one of them may be a default, indicated with the asterisk.\n\nAdditionally, the configuration value has a specified `:boolean` type,\nnecessary to convert the flag values as strings to their corresponding boolean\nvalue.\n\n```js\nvar Command = require('shon/command');\nvar command = new Command('soup', {\n    soup: '[--soup=true*|-s=true|--no-soup=false|-S=false] :boolean ' +\n        'Whether to serve soup'\n});\n\nvar config = command.exec(process.argv, 2);\n\nif (config.soup) {\n    console.log('Have soup');\n} else {\n    console.log('No soup for you');\n}\n```\n\n```\n$ serve\nHave soup\n\n$ serve --no-soup\nNo soup for you\n```\n\nIt is unnecessary to specify the `:boolean` for flags that take no argument and\ndo not specify their values: they are presumed to all set the config value to\ntrue.\n\n## Help Trumps All\n\nIdioms like ``[-h|--help]*`` and ``[-v|--version]*`` are special because they\ninvalidate all other required arguments.\nThe asterisk denotes \"trump flags\".\nIf the parser encounters one of these trump flags, it will bypass all further\nvalidation and simply return the name of the config variable instead of the\nconfig object.\n\nThis helpful command has a required argument, but if you provide `--help` on\nthe command line, the parser overlooks the missing argument and returns \"help\"\nso you can provide an alternate behavior.\n\n```js\nvar command = new Command('do', {\n    activity: '<activity>',\n    help: '[-h|--help]*'\n});\n\nvar config = command.exec();\n\nif (config === 'help') {\n    command._logUsage();\n    return;\n}\n\nconsole.log('doing activity:', config.activity);\n```\n\n## Subcommands\n\nCommands can have subcommands.\nThe selected command gets captured as a `{name, config}` object.\n\n```js\n'use strict';\n\nvar Command = require('..');\n\nvar command = new Command('db\\n' +\n    'A simple key-value store', {\n    action: {\n        get: {\n            key: '<key>'\n        },\n        set: {\n            key: '<key>',\n            value: '<value>'\n        },\n        rm: {\n            key: '<key>',\n            force: '[-f|--force]'\n        },\n        ls: {\n        }\n    }\n});\n\nvar config = command.exec();\nvar subconfig = config.action.config;\n\nvar store = {a: 10, b: 20, c: 30};\n\nswitch (config.action.name) {\n    case 'ls':\n        console.log(Object.keys(store));\n        break;\n    case 'get':\n        console.log(store[subconfig.key]);\n        break;\n    case 'set':\n        store[subconfig.key] = subconfig.value;\n        break;\n    case 'rm':\n        delete store[subconfig.key];\n        break;\n}\n```\n\n```\n$ db ls\n[ 'a', 'b', 'c' ]\n$ db set a 10\n$ db get a\n10\n$ db rm a\n```\n\n## Precompiled Usage\n\nThe Command object provides a thin veneer, easily bypassed.\nYou can precompile a command description or \"usage file\" to JSON and use that\nJSON blob directly.\nThe following is a `troll.usage` file.\n\n```\nusage: troll <name> <color> <airspeed>\nAnswer me these questions three, ere the other side ye see.\n\nname: [-n|--name] <name>\n    What is your name?\ncolor: [-c|--color] <color>\n    What is your favorite color?\nairspeed: [-a|--airpseed] <airspeed> :number\n    What is the average airspeed velocity of an unladen swallow?\nhelp: [-h|--help]*\n```\n\nShon provides a command line tool called `usage2json` that converts files in\nthis format to a JSON blob.\n\n```\nusage2json troll.usage > troll.json\n```\n\nYou can use the generated JSON directly.\nThis bypasses the usage parser entirely.\n\n```js\n'use strict';\n\nvar exec = require('../exec');\nvar logUsage = require('../log-usage');\nvar command = require('./troll.json')\nvar config = exec(command);\n\nif (config === 'help') {\n    return logUsage(command);\n}\n\nconsole.log('Name:', config.name);\nconsole.log('Color:', config.color);\nconsole.log('Airpseed:', config.airspeed);\n```\n\nThis does, however, somewhat compromise the extensibility of the command\ndescription since the JSON blob does not index terms both by their position and\nname.\n\n## Usage Grammar\n\nThe [grammar](usage.pegs) for parsing usage has the following semantics:\n\nEach term may have some combination of flags and an argument.\nFlags and arguments combine in various ways:\n\n-   `[-f|--flag]`\n    An optional flag.\n    Each flag may specify a value, like `-a=alpha|-b=beta`.\n    If none of the flags specify a value, the variable will be a boolean,\n    false by default, and switched to true by the presence of any of the flags.\n-   `[-f|--flag] <argument>`\n    A required argument, optionally specified with a flag.\n    So, if a command accepts multiple arguments, they will be taken from the\n    command line in order, but can be specified in any order using flags.\n-   `[-f|--flag <argument>]`\n    An optional flag with an argument.\n    The argument can only be specified with the flag.\n- `-f|--flag <argument>`\n    A required flag with an argument.\n    The argument can only be specified with the flag.\n- `<argument>`\n    A required argument.\n    The argument must appear in the declared order on the command line.\n\nFuture versions of this library intend to add support for other idioms,\nincluding the `-v/-q` idiom for upgrading or downgrading verbosity.\n\nBy default, an argument will set a single configuration value.\nHowever, with a collector annotation, each argument may append a value onto an array.\n\n-   `<argument>...`\n    An argument that may be specified any number of times.\n    The configuration value will be an array, empty by default.\n-   `<argument>{count}`\n    The argument must be specified exactly `count` times.\n-   `<argument>{min..}`\n    The argument must be specified at least `min` times.\n-   `<argument>{min..max}`\n    The argument must be specified at least `min` times and no more than `max` times.\n\nEach term may be followed by a type annotation.\n\n-   `:boolean` means that the argument must either be the string `true` or the\n    string `false`, with the corresponding boolean values.\n-   `:number` means that the argument must represent a number, not NaN.\n-   `:quantity` means that the argument must represent a positive integer.\n-   `:shon` means that the value of the argument must be expressed with SHON\n    (shell object notation), described hereafter.\n-   `:jshon` means that the value of the argument must be expressed with JSON\n    or SHON with JSON possibly embedded in place of values.\n-   `:json` means that the value of the argument must be expressed with JSON.\n-   `:input` produces a readable stream from a file name, or `-` for standard\n    input.\n    Standard input is implied if the argument is optional and the argument is\n    omitted.\n-   `:atinput` produces a readable stream, from the literal argument, or from a\n    file name if prefixed with `@`, or standard input if `@-`.\n-   `:output` produces a writable stream from a file name, or `-` for standard\n    output.\n    Standard output is implied if the argument is optional and omitted.\n\nFuture versions of this library will introduce further type annotations for\nreading and writing by file name or `-`.\n\n## Usage Model\n\nThe command usage model is designed with the intent that other libraries will\nprovide a higher level interface that produce it (like a tool that\nautomatically abbreviates and creates negative flags), and other utilities that\nwill consume it (like a tool that provides shell completion).\n\nThe `Command` constructor generates a command model object, suitable for\npassing to `exec`, `parse`, or `usage` functions, or a variety of other\npossible uses.\nThese functions require an object with the following shape:\n\n-   ``_name`` the name of the command.\n-   ``_terms`` is an array of terms.\n    Each term corresponds to a configuration variable and describes all of the\n    argument forms necessary to populate it.\n\nThe `Command` constructor also reveals each term by its name to make it easier\nto programmatically manipulate each term after the skeleton has been generated.\n\nEach term has the following shape:\n\n-   `name` the name of the corresponding configuration variable.\n-   `flags` an array of flags.\n-   `arg` the name of the term's argument or `null` if it does not accept one.\n-   `commands` an object mapping subcommand names to command shapes, or `null`\n    if not applicable.\n-   `collectorType` is `array` for arrays of any size or `null` if the term\n    collects a single value.\n    A future version may introduce a `difference` collector for upgrading or\n    downgrading a value.\n-   `type` is an arbitrary type name which may have custom parsers, converters,\n    validators, or collectors associated.\n    SHON provides behaviors for `boolean`, `number`, `quantity`, `json`,\n    `shon`, and `jshon`.\n-   `parser` is an optional parser constructor.\n-   `converter` is an optional converter object or function.\n-   `validator` is an optional validator object or function.\n-   `collector` is an optional collector object or function.\n-   `required` implies that this term must be specified on the command line.\n-   `optionalFlag` implies that this term's argument can be specified either in\n    order or earlier if specified with its flag.\n-   `minLength` if the term is an array, the minimum length, albeit 0\n-   `maxLength` if the term is an array, the maximum length, albeit Infinity\n\nA flag has the following shape:\n\n-   `flag` is the full text of the flag including the `-` or `--` prefix.\n-   `long` is `true` if the prefix is `--`\n-   `short` is `true` if the prefix is `-`\n-   `value` is the string representation of the value that this flag will set.\n    It will be converted and validated based on the term's type.\n-   `default` is `true` if the flag produces the default value.\n\n## Converters\n\nConverter objects implement a `convert` method. Converter functions accept a\nstring from the command line and return the corresponding JavaScript value.\nThey also receive an `iterator` and `delegate` object which can be used\nto report errors and halt the parser.\n\n```js\nfunction convertBoolean(string, iterator, delegate) {\n    if (string === 'true') {\n        return true;\n    } else if (string === 'false') {\n        return false;\n    } else {\n        delegate.error('Must be true or false');\n        delegate.cursor();\n    }\n}\n```\n\n## Validators\n\nValidator objects implement a `validate` method. Validate functions accept a\nvalue and return whether it is valid.\n\n...\n\n## Collectors\n\n...\n\n## Parsers\n\n...\n\n## Iterators\n\n...\n\n## Cursors\n\n...\n\n## Delegates\n\n...\n\n## SHON (SHell Object Notation)\n\nSHON is an idiomatic notation for expressing objects at the command line.\nAll of JSON can be expressed with SHON.\nSHON lends itself better to command line usage for the purposes of\ninterpolating variables and tab completion.\nAny parser can accept SHON with the `:shon` type annotation.\n\nType          | JSON                 | SHON\n------------- | -------------------- | ---------------------\nObject        | `{\"hello\": \"World\"}` | `[ --hello World ]`\nArray         | `[\"beep\", \"boop\"]`   | `[ beep boop ]`\nArray         | `[1, 2, 3]`          | `[ 1 2 3 ]`\nEmpty Array   | `[]`                 | `[ ]` or `[]`\nObject        | `{\"a\": 10, b: 20}`   | `[ --a 10 --b 20 ]`\nEmpty Object  | `{}`                 | `[--]`\nNumber        | `1`                  | `1`\nNumber        | `-1`                 | `-1`\nNumber        | `1e3`                | `1e3`\nString        | `\"hello\"`            | `hello`\nString        | `\"hello world\"`      | `'hello world'`\nString        | `\"10\"`               | `-- 10`\nString        | `\"-10\"`              | `-- -10`\nString        | `\"-\"`                | `-- -`\nString        | `\"--\"`               | `-- --`\nTrue          | `true`               | `-t`\nFalse         | `false`              | `-f`\nNull          | `null`               | `-n`\n\nSHON subexpressions can be interpolated with a bare `$SHON` variable.\nThe proper idiom for interpolating an arbitrary string in SHON is `--\n\"$VARIABLE\"`.\nThis ensures that the variable is interpreted as a string literal in place.\n\nThis package ships with a `shon` command for converting SHON to JSON at the\ncommand line.\n\n## Acknowledgements\n\nThis project is based on earlier work implemented for [NarwhalJS][] by Kris\nKowal, Tom Robinson, and Abhinav Gupta.\nAbhinav is responsible for having contrived the brilliant name, SHON.\n\n[NarwhalJS]: https://github.com/280north/narwhal\n\n---\n\nCopyright (c) 2009-2015 Contributors\nMIT License\n",
  "readmeFilename": "README.md",
  "_id": "shon@3.0.5",
  "dist": {
    "shasum": "1963efdd1f334004d5bc09eed9a73347e3f39678"
  },
  "_from": "shon@^3.0.5",
  "_resolved": "https://registry.npmjs.org/shon/-/shon-3.0.5.tgz"
}
