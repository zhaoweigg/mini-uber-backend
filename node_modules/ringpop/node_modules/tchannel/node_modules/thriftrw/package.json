{
  "name": "thriftrw",
  "version": "3.4.3",
  "description": "thrift encoding/decoding using bufrw",
  "keywords": [],
  "author": {
    "name": "Lei Zhao",
    "email": "leizha@uber.com"
  },
  "repository": {
    "type": "git",
    "url": "git://github.com/thriftrw/thriftrw-node.git"
  },
  "main": "index.js",
  "homepage": "https://github.com/thriftrw/thriftrw-node",
  "bugs": {
    "url": "https://github.com/thriftrw/thriftrw-node/issues",
    "email": "leizha@uber.com"
  },
  "contributors": [
    {
      "name": "Lei Zhao"
    }
  ],
  "dependencies": {
    "bufrw": "^1.2.1",
    "error": "7.0.2",
    "long": "^2.4.0"
  },
  "devDependencies": {
    "coveralls": "^2.10.0",
    "debug": "^2.1.2",
    "eslint": "^2.2.0",
    "fast-stats": "0.0.3",
    "faucet": "0.0.1",
    "istanbul": "^0.3.5",
    "itape": "^1.5.0",
    "jsen": "^0.6.0",
    "opn": "^1.0.1",
    "pegjs": "^0.8.0",
    "pre-commit": "0.0.9",
    "tape": "^2.0.0",
    "uber-licence": "^1.2.0"
  },
  "licenses": [
    {
      "type": "MIT",
      "url": "http://github.com/thriftrw/thriftrw-node/raw/master/LICENSE"
    }
  ],
  "scripts": {
    "add-licence": "uber-licence",
    "build-parser": "pegjs --allowed-start-rules Program --cache thrift-idl.pegjs && uber-licence --file thrift-idl.js > /dev/null",
    "check-cover": "istanbul check-coverage",
    "check-licence": "uber-licence --dry",
    "check-ls": "npm ls 1>/dev/null",
    "cover": "istanbul cover --report html --print none -- test/index.js | faucet && istanbul report text && npm run check-cover -s",
    "lint": "eslint .",
    "test": "npm run check-ls -s && npm run build-parser -s && npm run lint -s && npm run cover -s",
    "trace": "itape test/index.js --trace",
    "travis": "npm run cover -s && istanbul report lcov && ((cat coverage/lcov.info | coveralls) || exit 0)",
    "view-cover": "opn ./coverage/index.html"
  },
  "engines": {
    "node": ">= 0.10.x"
  },
  "pre-commit": [
    "check-licence",
    "test"
  ],
  "pre-commit.silent": true,
  "itape": {
    "trace": {
      "debuglog": [
        "thriftrw"
      ],
      "leakedHandles": {
        "timeout": 5001,
        "debugSockets": true
      },
      "formatStack": true
    }
  },
  "uber-ngen-version": "5.2.0",
  "readme": "# thriftrw\n\n<!--\n    [![build status][build-png]][build]\n    [![Coverage Status][cover-png]][cover]\n    [![Davis Dependency status][dep-png]][dep]\n-->\n\n<!-- [![NPM][npm-png]][npm] -->\n\nEncodes and decodes Thrift binary protocol and JavaScript object models\ndeclared in a Thrift IDL.\nThis is an alternative approach to using code generated from Thrift IDL source\nfiles with the `thrift` compiler.\n\nThriftRW supports encoding and decoding the protocol with or without Thrift IDL\nsources.\nWithout sources, it is still possible to read and write the Thrift binary\nprotocol in all of its structure using numbered fields for structs and not\ndiscerning the nuanced differences between binary and string, list and set, or\nnumber and enum.\n\nWith a Thrift IDL, ThriftRW is able to perform certain optimizations.\nThriftRW constructs model instances directly from the contents of a buffer\ninstead of creating an intermediate anonymous structural model.\nAs a consequence, it is able to quickly skip any unrecognized fields.\nThriftRW can also use the same struct constructor for every instance of a\nstruct, which should yield run-time performance benefits for V8 due to hidden\nclasses (not yet verified).\n\nThe scope of this project may eventually cover alternate Thrift binary\nencodings including the compact binary protocol.\n\nThis project makes extensive use of [bufrw][] for reading and writing binary\nprotocols, a component shared by [tchannel-node][], with which this library\nworks in concert.\n\n[bufrw]: https://github.com/uber/bufrw\n[tchannel-node]: https://github.com/uber/tchannel-node\n\n\n## Example\n\nThriftRW provides a Thrift constructor that models all of the services,\nfunctions, and types expressed in a ThriftIDL source file.\n\n```js\nvar fs = require('fs');\nvar path = require('path');\nvar Thrift = require('thriftrw').Thrift;\nvar source = fs.readFileSync(path.join(__dirname, 'meta.thrift'), 'ascii');\nvar thrift = new Thrift({source: source, strict: true});\n```\n\nConsider `meta.thrift`\n\n```thrift\nstruct HealthStatus {\n    1: required bool ok\n    2: optional string message\n}\n\nservice Meta {\n    HealthStatus health()\n    string thriftIDL()\n}\n```\n\nThe most common usage of a Thrift instance is to get the argument and result\ntypes of a function and use those types to read to or write from a buffer.\nThe `getType` and `getTypeResult` functions retrieve such models based on their name.\nFor example, the arguments struct for the health endpoint would be ``Meta::health_args``\nand its result struct would be ``Meta::health_result``.\n\n```js\nvar MetaHealthArgs = thrift.getType('Meta::health_args');\nvar MetaHealthResult = thrift.getType('Meta::health_result');\n```\n\nThe `getType` method will return the struct or throw an exception if one does not exist.\nThis is the appropriate method if `getType` should throw an error due to a\nprogrammer's mistake, where the Thrift source in question is checked into the same project\nand the method name is a literal.\n\nHowever, exceptions being an undesirable outcome for bad data from a user,\n`getTypeResult` returns a result object with either `err` or `value` properties set.\n\n```js\nvar res = thrift.getTypeResult(methodName + '_args');\nif (res.err) {\n    return callback(res.err);\n}\nvar ArgsStruct = res.value;\n```\n\nThe struct can be written or read to or from a buffer using the struct's `rw` instance.\nA RW (reader/writer) implements `byteLength(value)`, `writeInto(value, buffer,\noffset)`, `readFrom(buffer, offset)`, each of which return a result object as\nspecified by [bufrw][].\nThe value may be JSON, a POJO (plain old JavaScript object), or any instances\nof the Thrift model, like `new thrift.Health({ok: true})`.\n\nA struct can also be encoded or decoded using the ThriftStruct's own\n`toBuffer(value)`, `fromBuffer(buffer)`, `toBufferResult(value)`, and\n`fromBufferResult(buffer)` methods.\nThose with `Result` in their name return `Result` instances instead of throwing\nor returning the buffer or value.\n\n[TChannelASThrift][] employs this interface on your behalf, leaving the\napplication author to take arguments and call back with a result when using\nthe Thrift argument scheme and a given Thrift IDL.\n\n[TChannelAsThrift]: https://github.com/uber/tchannel-node/blob/master/as/thrift.js\n\n\n### Without Thrift IDL\n\nThriftRW provides `T` prefixed types for encoding and decoding the wire\nprotocol without Thrift IDL.\nThis is useful for applications like [TCap] that do not necessarily have a\nThrift IDL file on hand to make sense of structs by field numbers alone.\n\nThe following example illustrates reading and writing a struct.\nThriftRW exports `TStruct`, `TList`, and `TMap`.\nTStructs serve for arguments, results, and exceptions.\nTLists also serve for sets.\n\n```js\nvar thriftrw = require(\"thriftrw\");\nvar bufrw = require('bufrw');\n\nvar struct = new thriftrw.TStruct();\nstruct.fields.push(\n    new thriftrw.TField(thriftrw.TYPE.STRING, 1, new Buffer('hello')\n);\n\nvar buf = bufrw.toBuffer(thriftrw.TStructRW, struct);\nconsole.log('created a binary buffer of thrift encoded struct', buf);\n\nvar struct2 = bufrw.fromBuffer(thriftrw.TStructRW, buf);\nconsole.log('created a TStruct from a binary buffer', struct2);\n```\n\n## Readers and Writers\n\nReaders and Writers, or RWs, are objects that capture the methods necessary to\nread and write a particular value to and from a buffer.\nRW objects implement:\n\n- `toBuffer(value):Result{err, buffer}`\n- `fromBuffer(buffer, offset=0):Result{err, value}`\n\n- `readFrom(buffer, offset):ReadResult{err, offset, value}`\n- `writeInto(value, buffer, offset):WriteResult{err, offset, value}`\n- `byteLength(value):LengthResult{err, length}`\n\n- `poolReadFrom(result, buffer, offset):ReadResult{err, offset, value}`\n- `poolWriteInto(result, value, buffer, offset):WriteResult{err, offset, value}`\n- `poolByteLength(result, value):LengthResult{err, length}`\n\nAll of these methods return result objects, which will either have their `err`\npopulated with an error, or other properties for the success value.\nThe pool* methods also accept a result object for reuse.\nThat result object must implement `reset(err, ...properties)`.\n\nThe RW is the both the building block and the public interface of ThriftRW.\n\n\n## Thrift Model\n\nThrift has internal models for modules, services, types, and values.\nThese models are indexed by name on each Thrift module in the `models` object.\nEach of these models has a \"surface\", which is a constructor for types, values\nfor constants, an index of functions for services, and the model itself for\nmodules.\nModules expose their names on their own object only if they start with a\nnon-lower-case character, to avoid name collisions with other properties and\nmethods, but are always also available through the index for their type class,\nlike `thrift.consts.PI`.\n\nThe Meta service is simply `thrift.Meta`.\nThe object is an object mapping functions by name, so `thrift.Meta.health` is\nthe interface for accessing the `args` and `result` structs for the\n`Meta::health` function.\n\n```js\nvar args = new thrift.Meta.health.Arguments({ok: true});\nvar result = new thrift.Meta.health.Result({success: null});\n```\n\nThe Thrift instance also has a `services` property containing the actual\nThriftService instance indexed by service name.\nThriftService instances are not expected to be useful outside the process of\ncompiling and linking the Thrift IDL, but you can use the services object to\ncheck for the existence of a service by its name.\n\n### Messages\n\nApache Thrift over HTTP envelopes arguments and result structs with a message\nthat contains a sequence number, the function name, a message type, and\nfollowed by the message body.\n\nThrift over TChannel does not use Thrift envelopes.\nTChannel does not need or use the Thrift sequence number, since it abstracts\nmultiplexing with its own transport frame identifiers.\nThe function name is expressed as Service::function in TChannel's arg1.\nThe message type corresponds to the TChannel frame type.\nThe message body corresponds to TChannel's arg3.\n\nSince HTTP/1.1 only allows one outstanding request and response on the wire at\nany time, and HTTP/1.1 with the ill-fated \"pipeline\" mode allows requests and\nresponses to be sent FIFO but forbids out-of-order responses, the sequence\nnumber is useless.\nHTTP/2.0 does support multiplexing, but does not require sequence identifiers\nin the request or response body to do so.\nDespite this folly, HTTP request handlers are obliged to use envelopes and\nmatch the number of a response to the number of a request, but callers are not\nobliged to choose sensible sequence numbers.\n\nBy default, services dispatch on the given function name. Services that\nimplement multiple Thrift services have the option of requiring the Thrift\nservice name and function name in the message envelope, with an arbitrary\ndelimiter, typically a single colon, e.g., \"Service:function\".\nOver TChannel, this corresponds to the frame's arg1 and is always\n\"Service::function\", the service name and function name delimited by two\ncolons.\n\nThe message type is an enumeration of one of 'CALL', 'ONEWAY', 'RESULT', or\n'EXCEPTION'.\n'CALL' and 'ONEWAY' are appropriate for requests, where 'ONEWAY' is for\nfunctions with the `oneway` Thrift IDL modifier keyword, implying they expect\nno response.\n'RESULT' is for both Thrift success and exception cases.\nFor exceptions that cannot be captured by the Thrift result struct, the\n'EXCEPTION' message type implies that the body is a Thrift exception struct of\nthe following shape instead of the result struct from the IDL.\n\n```thrift\nenum ExceptionType {\n  UNKNOWN = 0\n  UNKNOWN_METHOD = 1\n  INVALID_MESSAGE_TYPE = 2\n  WRONG_METHOD_NAME = 3\n  BAD_SEQUENCE_ID = 4\n  MISSING_RESULT = 5\n  INTERNAL_ERROR = 6\n  PROTOCOL_ERROR = 7\n  INVALID_TRANSFORM = 8\n  INVALID_PROTOCOL = 9\n  UNSUPPORTED_CLIENT_TYPE = 10\n}\n\nstruct TApplicationException {\n  1: optional string message\n  2: optional ExceptionType type\n}\n```\n\nThese cases are expressed in TChannel instead with an Error frame with the\ncorresponding TChannel transport error code and an arbitrary message.\n\nThe base message envelope constructor is available as the `thrift.Message`,\nthat is also a copy constructor.\nMessages have the following properties:\n\n- `version` defaults to 0. Version 1 has a more elaborate message header that\n  expresses the message envelope version number and provides no additional\n  value. There may or may never be another message envelope version.\n- `type` is one of 'CALL', 'ONEWAY', 'RESULT', or 'EXCEPTION'\n- `id` is a sequence number. Really, it is any number. If you are a client, you\n  can pick. If you are a server, you must respect the client's choice and send\n  back the same id in the response message.\n- `body` is either your result object, or a `TApplicationException`.\n\nThriftRW provides reader/writer objects for the arguments and result message\nenvelopes on the function model.\nThe function model is addressable as `thrift.{Service}.{function}`.\n\n- `argumentsMessageRW`\n- `resultMessageRW`\n\n### Structs\n\nThriftStruct models can be constructed with an optional object of specified\nproperties.\nThriftRW exposes the constructor for a struct declaration by name on the thrift\ninstance, as in `thrift.Health` for the meta.thrift example.\n\n```js\nvar HealthStruct = thrift.Health;\nvar result = new ResultStruct({\n    success: new HealthStruct({ok: true })\n})\n```\n\nUnspecified properties will default to null or an instance of the default value\nspecified in the Thrift IDL.\nNested structs can be expressed with JSON or POJO equivalents.\nThe constructors perform no validation.\nInvalid objects are revealed only in the attempt to write one to a buffer.\n\n```js\nvar result = new ResultStruct({success: {ok: true}});\n```\n\nEach constructor has a `rw` property that reveals the reader/writer instance.\nEach constructor also hosts `toBuffer(value)`, `fromBuffer(buffer)`,\n`toBufferResult(value)`, and `fromBufferResult(buffer)`.\n\nStructs are indexed by name on the `thrift.structs` object and aliased on the\nthrift object if their name does not start with a lower-case letter.\n\n### Exceptions\n\nThriftException extends ThriftStruct.\nExceptions are modeled as structs on the wire, and are modeled as JavaScript\nexceptions instead of regular objects.\nAs such they have a stack trace.\nThriftRW exposes the exception constructor by name on the thrift instance.\n\n```thrift\nexception Pebcak {\n    1: required string message\n    2: required string keyboardName\n    3: required string chairName\n}\n```\n\n```js\nvar error = new thrift.Pebcak({\n    message: 'Problem exists between chair and keyboard',\n    chairName: 'Hengroen',\n    keyboardName: 'Excalibur'\n});\n```\n\nExceptions are indexed by name on the `thrift.exceptions` object and aliased on\nthe thrift object if their name does not start with a lower-case letter.\n\n### Including other Thrift IDL files\n\nTypes, services, and constants defined in different Thrift files may be referenced by using include statements with paths relative to the current .thrift file. The paths must be in the form ./foo.thrift, ./foo/bar.thrift, ../baz.thrift, and so on.\n\nIncluded modules will automatically be interpreted along with the module that included them, and they will be made available in the generated module with the base name of the included file.\n\nFor example, given:\n\n```\n// shared/types.thrift\n\nstruct UUID {\n    1: required i64 high\n    2: required i64 low\n}\n```\n\nAnd:\n\n```\n// services/user.thrift\n\ninclude \"../shared/types.thrift\"\n\nstruct User {\n    1: required types.UUID uuid\n}\n```\n\nYou can do the following\n\n```js\nvar path = require('path');\nvar Thrift = require('thriftrw').Thrift;\nvar service = new Thrift({\n  entryPoint: path.resolve(__dirname, 'services/user.thrift'),\n  allowFilesystemAccess: true\n});\n\nvar userUuid = service.modules.types.UUID({\n  high: ...,\n  low: ...\n});\n\nvar user = service.User({\n  uuid: userUuid\n});\n```\n\n### Aliasing/Renaming Includes\n\nthriftrw-node contains experimental include-as support. This lets you include a file aliasing it to a different name than that of the file. This feature is hidden behind a flag and should not be used until support for include-as aliasing is supported by other language implementations of thriftrw.\n\nUnaliased include:\n```\ninclude \"../shared/Types.thrift\"\n```\n\nAliased include:\n```\ninclude Types \"../shared/types.thrift\"\n```\n\nTo enable this you need to create a `Thrift` with the `allowIncludeAlias` option set to true. e.g.\n\n```js\nvar thrift = new Thrift({\n  thriftFile: /* path to main thrift file */,\n  allowIncludeAlias: true,\n  allowFilesystemAccess: true\n});\n```\n\n### Definitions with PascalCase Identifiers are Exposed\n\nThe surface of any Thrift object will expose definitions as top level properties on an object if the identifier for that definition is PascalCased. In the include example above this can be seen. The filename for the `types.thrift` file is not PascalCase so it needed to be reached via the modules property. If the filename had instead been PascalCased, like `Types.thrift` or imported as `Types`, that module could have been accessed directly via `service.Types.UUID`;`\n\n### Unions\n\nThriftUnion also extends ThriftStruct.\nUnions are alike to structs except that fields must not be marked as `optional`\nor `required`, cannot have a default value, and exactly one must be defined on\nan instance.\nAs with other types, validation of a union only occurs when it is read or\nwritten.\n\n```thrift\nunion CoinToss {\n    1: Obverse heads\n    2: Reverse tails\n}\n\nstruct Obverse {\n    1: required string portrait;\n    2: required i32 year;\n}\n\nstruct Reverse {\n    1: required string structure;\n    2: optional string motto;\n}\n```\n\n```js\nvar coinToss = new thrift.CoinToss({\n    head: thrift.Obverse({\n        portrait: 'TK',\n        year: 2010\n    })\n})\n```\n\nUnions are indexed by name on the `thrift.unions` object and aliased on the\nthrift object if their name does not start with a lower-case letter.\n\n### Enums\n\nThrift enumerations are surfaced as an object mapping names to strings on\nthe thrift instance.\n\n```thrift\nenum CoinToss {\n    tails = 0\n    heads = 1\n}\n```\n\n```js\nvar result = Math.random() < 0.5 ?\n    thrift.CoinToss.heads :\n    thrift.CoinToss.tails;\n// result will be either \"tails\" or \"heads\"\n```\n\nThriftRW hides the detail of which numeric value an enumeration will have on\nthe wire and allows an enumeration to be represented in JSON by name.\nThis is a deliberate departure from the norms for Thrift in other languages\nto take advantage of the dynamic nature of JavaScript, permit duck typing,\nenforce loose coupling between application code and wire protocol, and make\nThrift expressible as JSON on the command line with [TCurl][]\n\n[TCurl]: https://github.com/uber/tcurl\n\nEnums are indexed by name on the `thrift.unions` object and aliased on the\nthrift object if their name does not start with a lower-case letter.\n\n### Consts\n\nThrift constants are surfaced as properties of the thrift instance.\n\n```thrift\nconst PI = 3\nconst TAU = 6\n```\n\n```js\nvar PI = thrift.PI;\nvar TAU = thrift.TAU;\n```\n\nConsts are indexed by name on the `thrift.consts` object and aliased on the\nthrift object if their name does not start with a lower-case letter.\n\n\n## Enhancements and Departures from Thrift proper\n\nThriftRW operates in a \"strict\" mode by default that imposes additional\nconstraints on Thrift to ensure cross language interoperability between\nJavaScript, Python, Go, and Java, the four Thrift bindings favored at Uber.\n\nIn strict mode, structs must explicitly declare every field to be either\nrequired, optional, or have a default value.\n\nThriftRW supports forward references and self-referential types (like trees)\nwithout special demarcation.\nThriftRW also supports forward references in default values and constants.\n\n## Types and Annotations\n\nThriftRW respects certain annotations specific to the treatment of various\ntypes in JavaScript.\n\n### set\n\nThere is an emerging standard for the representation of sets in JavaScript.\nUntil that standard becomes pervasive, sets are traditionally represented\neither as an array with externally enforced constraints, or as long as the values\nare scalar like numbers and strings, as an Object with values for keys.\n\nBy default, ThriftRW encodes and decodes sets as arrays.\nThriftRW does nothing to enforce uniqueness.\n\nAdditionally, the `js.type` annotation can be set to \"object\" if the value type\nis a string, i16, or i32.\nThriftRW will ensure that the keys are coerced to and from Number for numeric\nvalue types.\n\n```thrift\ntypedef set<string> (js.type = 'object') StringSet\ntypedef set<i32> (js.type = 'object') I32Set\n```\n\n### map\n\nThere is also an emerging standard for the representation of maps in JavaScript.\nHowever, until support is more pervasive, ThriftRW supports representing maps\nas either an object with scalar key types or an entries array for all others.\n\nMaps are represented as objects by default. With the `js.type` annotation set\nto \"entries\", the map will be encoded and decoded with an array of [key, value]\nduples.\n\n```thrift\ntypedef map<string, string> Dictionary\ntypedef map<Struct, Struct> (js.type = 'entries') StructsByStructs\n```\n\n### i64\n\nJavaScript numbers lack sufficient precision to represent all possible 64 bit\nintegers.\nThriftRW decodes 64 bit integers into a Buffer by default, and can coerce\nvarious types down to i64 for purposes of expressing them as JSON or plain\nJavaScript objects.\n\n- A number up to the maximum integer precision available in JavaScript.\n- A `{hi, lo}` or `{high, low}` pair of 32 bit precision integers.\n- A 16 digit hexadecimal string, like `0102030405060708`.\n- An array of 8 byte values. Ranges are not checked, but coerced.\n- An 8 byte buffer.\n\nThriftRW supports a type annotation for i64 that reifies i64 as an instance of\n[Long][], an object that models a 64 bit number as a `{high, low}` pair of 32\nbit numbers and implements methods for common mathematical operators.\n\n```thrift\ntypedef i64 (js.type = 'Long') long\n```\n\nPlease use the [Long][] package for operating with such numbers.\nA backward-incompatible release may make this form the default for reading.\n\nWith the Long type annotation, ThriftRW performs the following conversions on\nyour behalf.\n\n```js\nvar Long = require('long');\n\n// From a buffer to a long\nvar buf = new Buffer(\"0102030405060708\", \"hex\");\nvar num = Long.fromBits(buf.readInt32BE(4, true), buf.readInt32BE(0, true));\n\n// From a long to a buffer\nvar buf = new Buffer(8);\nbuf.writeUInt32BE(num.high, 0, 4, true);\nbuf.writeUInt32BE(num.low, 4, 4, true);\n```\n\n[Long]: https://www.npmjs.com/package/long\n\n### Timestamps\n\nThe convention for expressing timestamps at Uber is to use an i64 for\nUTC milliseconds since the UNIX epoch.\nPreviously, some services were found spending an unreasonable amount of time\nparsing timestamp strings.\nThriftRW supports a `(js.type = 'Date')` annotation on i64.\n\n```thrift\ntypedef i64 (js.type = 'Date') timestamp\n```\n\nThis will reify timestamps as a JavaScript Date and ThriftRW will accept an\nISO-8601 timestamp or milliseconds since the epoch (as returned by\n`Date.now()`) in place of a Date, as well as the equivalent in buffers or\narrays of bytes.\n\nFor [TCurl][], this means that you can both read and write ISO-8601 for\ntimestamps.\n\n[TCurl]: https://github.com/uber/tcurl\n\n## Related\n\n[thriftrw-python] is the sister library for Python.\n\n[thriftrw-python]: https://github.com/thriftrw/thriftrw-python\n\n## Installation\n\n`npm install thriftrw`\n\n## Tests\n\n`npm test`\n\n## NPM scripts\n\n - `npm run add-licence` This will add the licence headers.\n - `npm run cover` This runs the tests with code coverage\n - `npm run lint` This will run the linter on your code\n - `npm test` This will run the tests.\n - `npm run trace` This will run your tests in tracing mode.\n - `npm run travis` This is run by travis.CI to run your tests\n - `npm run view-cover` This will show code coverage in a browser\n\n## Contributors\n\n - Lei Zhao @leizha\n - Kris Kowal @kriskowal\n - Andrew de Andrade @malandrew\n\n## MIT Licenced\n\n  [build-png]: https://secure.travis-ci.org/uber/thriftrw.png\n  [build]: https://travis-ci.org/uber/thriftrw\n  [cover-png]: https://coveralls.io/repos/uber/thriftrw/badge.png\n  [cover]: https://coveralls.io/r/uber/thriftrw\n  [dep-png]: https://david-dm.org/thriftrw/thriftrw-node.png\n  [dep]: https://david-dm.org/thriftrw/thriftrw-node\n  [test-png]: https://ci.testling.com/uber/thriftrw.png\n  [tes]: https://ci.testling.com/uber/thriftrw\n  [npm-png]: https://nodei.co/npm/thriftrw.png?stars&downloads\n  [npm]: https://nodei.co/npm/thriftrw\n",
  "readmeFilename": "README.md",
  "_id": "thriftrw@3.4.3",
  "dist": {
    "shasum": "9788327b9c8250aae4134c8be33defd5ca16b583"
  },
  "_from": "thriftrw@^3.4.3",
  "_resolved": "https://registry.npmjs.org/thriftrw/-/thriftrw-3.4.3.tgz"
}
